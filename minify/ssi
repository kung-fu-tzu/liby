#!/usr/bin/perl

our $VIRTUAL_PATH = '';
our $SSI_BASE_PATH = '';

map { /^(\w+)=(.*)$/ and $$1 = $2 } @ARGV;

use strict;

my %virtuals;
my $virtuals_rex = [];
map { /^(.*?)=(.*)$/ and $virtuals{$1} = $2 and push @$virtuals_rex, $1 } split ';', $VIRTUAL_PATH;
$virtuals_rex = '^(' . join('|', @$virtuals_rex) . ')';
$virtuals_rex = qr($virtuals_rex);
# warn $virtuals_rex;

$/ = undef;
print parse($SSI_BASE_PATH || './STDIN', <STDIN>);

sub parse
{
	my ($fn, $text) = @_;
	# warn "parse: $fn";
	my $path = $fn;
	$path =~ s~[^/]*$~~;
	
	my @parts = split /<!--\s*#(.*?)-->/, $text;
	my @codes;
	my @datas;
	my %ssi;
	my %ops;
	my $out = '';
	
	# warn $#parts;
	my $sub_data = sub
	{
		my $str = shift;
		push @datas, $str;
		return "\$out .= \$datas[$#datas];";
	};
	
	my $sub_statement = sub
	{
		my $str = shift;
		$str =~ m/^\s*(\w+)\s+(.*?)$/;
		my ($name, $params) = ($1, $2);
		# warn "$name: $params";
		my %params;
		$params{$1} = $2 while $params =~ m/\s*(\w+)="((?:\\.|.)*?)"\s*/g;
		# warn $name, %params;
		if (my $op = $ops{$name})
		{
			return $op->(\%params);
		}
		else
		{
			my $sub = $ssi{$name}
				or die "Unknown SSI command '$name' in $fn";
			push @codes, sub { $sub->(\%params) };
			return "\$codes[$#codes]();";
		}
	};
	
	$ssi{include} = sub
	{
		my $prms = shift;
		my $fn;
		if ($fn = $prms->{virtual})
		{
			$fn =~ s/$virtuals_rex/$virtuals{$1}/e
		}
		elsif ($fn = $prms->{file})
		{
			$fn !~ m~^/~ and $fn = $path . $fn;
		}
		else
		{
			return warn 'include: empty file and virtual name';
		}
		
		open my $fh, '<', $fn
			or return warn "Can`t include file '$fn' at path '$path': $!";
		select((select($fh),$/=undef)[0]);
		my $text = <$fh>;
		close $fh;
		$out .= parse($fn, $text);
	};
	
	$ssi{set} = sub
	{
		my $prms = shift;
		$::{$prms->{var}} = $prms->{value};
	};
	
	$ops{if} = sub
	{
		my $prms = shift;
		my $expr = $prms->{expr};
		$expr =~ s/^\s*(\S+)\s*=\s*\//$1=~\//;
		$expr =~ s/^\s*(\S+)\s*!=\s*\//$1!~\//;
		return "if ($expr) { ";
	};
	
	$ops{endif} = sub
	{
		my $prms = shift;
		my $expr = $prms->{expr};
		return "}";
	};
	
	
	
	my $i = 0;
	@parts = map { $i++ % 2 ? $sub_statement->($_) : $sub_data->($_) } @parts;

	$text = join ' ', 'no strict;', @parts;
	# warn $text;
	eval $text;
	return $out;
	die if $@;
}

